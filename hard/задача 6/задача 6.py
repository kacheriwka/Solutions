def f(a):
    return [a[i:i+3] for i in range(0,len(a),3)] #сделал функцию, дробящую значения в списке на вложенные списки
                #функция работает на срезах списка. каждый раз в наш список на вывод добавляется вложенный список, состоящий
    #из трех элементов основного списка. если не будет хватать элементов - сделает вложенный список с меньшим числом элементов
#-------------------------------------------------------------------------------------------------------------------------------
k = 0 #количество чисел
m = 0 #максимальное число
for x in range(100000,300001):  # Перебираем числа в нашем диапазоне.
    sq = int(x ** 0.5)  # Целая часть квадратного корня числа
    d = set()  # Множество, куда мы будем забивать делители. Множество потому-что в нем не может быть повторений.
    for i in range(2, sq + 1):  # Перебираем делители.
        if x % i == 0:  # Если мы нашли таковые, то добавляем 2 числа. Само i и x // i в пару.
            d.add(i)
            d.add(x // i)
    d = list(map(lambda x: sum(x), [x for x in f(sorted(d)) if len(x) == 3])) #ПЕРЕД ДАЛЬНЕЙШИМ ИЗУЧЕНИЕМ ПРОГРАММЫ ЧИТАТЬ ВНИЗУ
    if len(d) == 7: #если длина обновленного списка d равна семи, прибавляю единичку к количеству
        k+=1
        if max(d)%123==0 and max(d)>m: #если максимальный элемент списка d делится на 123 и он больше m - то m = max(d)
            m = max(d)
    print(k,m)

"d = list(map(lambda x: sum(x), [x for x in f(sorted(d)) if len(x) == 3]))"
#я дроблю список делителей функцией f(d), фильтруя те элементы списка, длина которых меньше трех
#при помощи функции map() я применяю ко всем элементам списка лямбда-функцию, заставляя все вложенные списки сложиться
#т.к мы получили итератор, который просто так не прочитать, я превращаю его в список